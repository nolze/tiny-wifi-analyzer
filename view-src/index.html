<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>wifi-analyzer</title>
    <style>
      html,
      body {
        margin: 0;
        padding: 0;
        overscroll-behavior-x: none;
        font-family: ui-sans-serif, system-ui, sans-serif;
      }

      body {
        padding-top: 20px;
        padding-bottom: 10px;
        padding-left: 10px;
        padding-right: 20px;
      }

      .chart {
        width: 100%;
        max-width: 1200px;
        max-height: 800px;
        margin: 0 auto;
      }

      .annotation {
        font-family: sans-serif;
      }
    </style>
  </head>

  <body>
    <div style="display: flex; flex-wrap: wrap">
      <div class="chart" id="chart24"></div>
      <div class="chart" id="chart5"></div>
      <div class="chart" id="chart6"></div>
    </div>
    <script type="module">
      import ApexCharts from "apexcharts";

      const CHANNEL_NUMBER_MAX_24 = 16;
      const CHANNEL_NUMBER_MAX_5 = 170;
      const CHANNEL_NUMBER_MAX_6 = 233;

      let lastZoom = {};

      function makeOptions(bandName, channels) {
        const options = {
          series: [],
          chart: {
            type: "area",
            zoom: {
              enabled: true,
              allowMouseWheelZoom: false,
              // autoScaleYaxis: false,
            },
            animations: {
              enabled: false,
            },
            events: {
              beforeResetZoom: (chart) => {
                lastZoom[bandName] = undefined;
                // chart.w.globals.lastXAxis.min = undefined;
                // chart.w.globals.lastXAxis.max = undefined;
                return true;
              },
              beforeZoom: (chart, { xaxis, yaxis }) => {
                let newXaxis = { ...xaxis };
                const minRange = 2;
                if (xaxis.max - xaxis.min < minRange) {
                  const mid = (xaxis.min + xaxis.max) / 2;
                  // desired +/-1 around midpoint to produce a minimum range of 2
                  const desiredMin = mid - 1;
                  const desiredMax = mid + 1;
                  let min = Math.max(channels[0], desiredMin);
                  let max = Math.min(channels[channels.length - 1], desiredMax);
                  // If clamping reduced the range below 2, try to expand the other side(s)
                  if (max - min < minRange) {
                    const deficit = minRange - (max - min);
                    // Prefer expanding lower bound first
                    min = Math.max(channels[0], min - deficit);
                    // If still not enough, expand the upper bound
                    if (max - min < minRange) {
                      const remaining = minRange - (max - min);
                      max = Math.min(
                        channels[channels.length - 1],
                        max + remaining,
                      );
                    }
                  }
                  newXaxis = { min, max };
                }
                return { xaxis: newXaxis, yaxis };
              },
              zoomed: (_chart, { xaxis, yaxis }) => {
                lastZoom[bandName] = [xaxis.min, xaxis.max];
                return true;
              },
              updated: (chart, options) => {
                if (
                  lastZoom[bandName] &&
                  (options.config.xaxis.min !== lastZoom[bandName][0] ||
                    options.config.xaxis.max !== lastZoom[bandName][1])
                ) {
                  // chart.updateOptions({
                  //   chart: {
                  //     animations: { dynamicAnimations: { enabled: false } },
                  //   },
                  // });
                  chart.zoomX(lastZoom[bandName][0], lastZoom[bandName][1]);
                  // chart.updateOptions({
                  //   chart: {
                  //     animations: { dynamicAnimations: { enabled: true } },
                  //   },
                  // });
                }
              },
            },
            toolbar: {
              tools: {
                // zoom: true,
                pan: false,
                zoomin: false,
                zoomout: false,
                reset:
                  '<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24"><path fill="currentColor" d="M12 16v-2.5q0-.625.438-1.062T13.5 12H16v1.5h-2.5V16zm1.5 6q-.625 0-1.062-.437T12 20.5V18h1.5v2.5H16V22zm7-6v-2.5H18V12h2.5q.625 0 1.063.438T22 13.5V16zM18 22v-1.5h2.5V18H22v2.5q0 .625-.437 1.063T20.5 22zm2.775-12H18.7q-.65-2.2-2.475-3.6T12 5Q9.075 5 7.037 7.038T5 12q0 1.8.813 3.3T8 17.75V15h2v6H4v-2h2.35Q4.8 17.75 3.9 15.938T3 12q0-1.875.713-3.512t1.924-2.85t2.85-1.925T12 3q3.225 0 5.663 1.988T20.775 10"/></svg>',
              },
              export: {
                csv: {
                  filename: "export",
                  headerCategory: "channel",
                  headerValue: "rssi",
                },
                svg: {
                  filename: "export",
                },
                png: {
                  filename: "export",
                },
              },
            },
          },
          plotOptions: {
            area: {
              fillTo: "end",
            },
          },
          stroke: {
            curve: "smooth",
          },
          legend: {
            showForSingleSeries: true,
            position: "left",
            onItemClick: {
              toggleDataSeries: false,
            },
            formatter: (seriesName, { seriesIndex, w }) => {
              const yValue = w.config.series[seriesIndex].data[1][1];
              const xValue = w.config.series[seriesIndex].data[1][0];
              return [
                `Channel: ${xValue} RSSI: ${yValue}dBm`,
                "<br>",
                `<b>${seriesName}</b>`,
              ];
            },
          },
          xaxis: {
            type: "category",
            categories: channels,
            min: channels[0],
            max: channels[channels.length - 1],
            tickAmount: Math.min(channels.length - 1, 15),
            tickPlacement: "on",
            labels: {
              rotate: false,
              hideOverlappingLabels: true,
            },
            title: {
              text: "channel",
            },
            tooltip: {
              enabled: false,
            },
            crosshairs: {
              show: false,
            },
          },
          yaxis: {
            type: "numeric",
            min: -100,
            max: 0,
            title: {
              text: "dBm",
            },
            tooltip: {
              enabled: false,
            },
          },
          grid: {
            xaxis: {
              lines: {
                show: true,
              },
            },
          },
          dataLabels: {
            enabled: true,
            formatter: (val, { seriesIndex, dataPointIndex, w }) => {
              if (val === -100) return "";
              const name = w.config.series[seriesIndex].name;
              const ch = w.config.series[seriesIndex].data[1][0];
              return `${ch} ${name}`;
            },
          },
          markers: {
            size: 0,
          },
          tooltip: {
            enabled: false,
            shared: false,
            intersect: false,
            // custom: () => '',
            marker: {
              show: false,
            },
            onDatasetHover: {
              highlightDataSeries: true,
            },
            x: {
              formatter: (
                value,
                { series, seriesIndex, dataPointIndex, w },
              ) => {
                return series[seriesIndex][1];
              },
            },
            y: {
              formatter: (
                value,
                { series, seriesIndex, dataPointIndex, w },
              ) => {
                return series[seriesIndex][1];
              },
            },
            // items: {
            //   display: 'none',
            // },
          },
          title: {
            text: bandName,
          },
          noData: {
            text: "Loading...",
            align: "center",
            verticalAlign: "middle",
            style: {
              color: "#888",
              fontSize: "16px",
              fontFamily: "sans-serif",
            },
          },
        };
        return options;
      }

      window.init = (bands) => {
        const chart24 = window.chart24;
        const chart5 = window.chart5;
        const chart6 = window.chart6;

        if (bands["24"]) {
          const options24 = makeOptions(
            "2.4GHz",
            [...Array(CHANNEL_NUMBER_MAX_24).keys()].map((v) => v + 1),
          );
          const chart24 = new ApexCharts(
            document.querySelector("#chart24"),
            options24,
          );
          window.chart24 = chart24;
          chart24.render();
        }

        if (bands["5"]) {
          const options5 = makeOptions(
            "5GHz",
            [...Array(CHANNEL_NUMBER_MAX_5).keys()].map((v) => v + 1),
          );
          const chart5 = new ApexCharts(
            document.querySelector("#chart5"),
            options5,
          );
          window.chart5 = chart5;
          chart5.render();
        }

        if (bands["6"]) {
          const options6 = makeOptions(
            "6GHz",
            [...Array(CHANNEL_NUMBER_MAX_6).keys()].map((v) => v + 1),
          );
          const chart6 = new ApexCharts(
            document.querySelector("#chart6"),
            options6,
          );
          window.chart6 = chart6;
          chart6.render();
        }
      };
    </script>
  </body>
</html>
